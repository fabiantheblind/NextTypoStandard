// connectedNodes.jsx// see the video to this script over at vimeo// http://vimeo.com/28665864 (lowres)// the nodes get connected by their distance to each other// if a node connects the range it can connect with other nodes increases// color and opacity also change according to the connections//// see also the processing code --> http://fabiantheblind.tumblr.com/post/9878896421/connected-nodes-processing//// Copyright (C) 2011 Fabian "fabiantheblind" Morón Zirfas// http://www.the-moron.net// info [at] the - moron . net// This program is free software: you can redistribute it and/or modify// it under the terms of the GNU General Public License as published by// the Free Software Foundation, either version 3 of the License, or// any later version.// This program is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the// GNU General Public License for more details.// You should have received a copy of the GNU General Public License// along with this program.  If not, see <http://www.gnu.org/licenses/.// illustratormain();function main(){var DEBUG = true;//the more nodes the more it will bee connected// number of nodes. Between 1500 and 2500 is nice// or you sice up the documentsizevar num = 1500; var distance = 17; // the startin distance to reach for others// this is the factor that increments the "reach / distance"// a node can connect with othersvar incrFac = 2; // keep this very lowvar nodes = new Array(); // an array to keep the nodes in// some defaultsvar docPreset = new DocumentPreset;docPreset.width = 800.0;docPreset.height = 500.0;docPreset.units = RulerUnits.Pixels;var doc = documents.addDocument(DocumentColorSpace.RGB, docPreset);var width = doc.width;var height = doc.height;doc.defaultStrokeCap = StrokeCap.ROUNDENDCAP;// colorsvar fillColor = new RGBColor;fillColor.red = 190;fillColor.green = 190;fillColor.blue = 190;var strkColor = new RGBColor;strkColor.red = 128;strkColor.green = 128;strkColor.blue = 128;  // this initalizes the nodes        // loop thru num o nodes    for(var i = 0; i < num; i++){      // make a random points       var x = Math.random()*width;      var y = Math.random()*height;      var pos = [x,y];// position into PVector       nodes.push(pos); // add the new node to the list    }// close first loop  var n;// keep it clear         for(var j = 0; j < nodes.length; j++){    var f = 190; // the inital colorvalue    var fillColor = new RGBColor;        fillColor.red = f;        fillColor.green = f;        fillColor.blue = f;                n = nodes[j];        var diam = 3;// start diameter        var o = 23; // start opacity    // call the functions of node       var cons = 0; // number of connections  for(var k = 0; k < nodes.length; k ++){      var  v1 = n; // position of the refrence positoin      var  v2 = nodes[k]; // every other node            // these are the points of the node and the      // other nodes in the loop      // only for testing      var x =  v1[0];      var y =  v1[1];      var x0 = v2[0];      var y0 = v2[1];            var d = calcDistance(n,nodes[k]);// clac distance      // now if the node already has some connections      // make the diastance he can check higher                  if((d < distance +cons*incrFac ) &&(d > 1)){                    // create the lines       var myLine = doc.pathItems.add();        myLine.stroked = true;        myLine.setEntirePath( Array(nodes[k], n));        myLine.strokeColor = strkColor;        myLine.filled = false;        myLine.strokeWidth = 0.5;        myLine.opacity = o;               var lnsTags = myLine.tags.add();     lnsTags.name = "line";                      // now there is a connection              // so increment all the values                cons++; // increment num                diam+=0.25;                o++;                f++; // or decrement. as you like (this makes it lighter)                // constrain the opacity                if(o >= 90){                    o = 90;                     }// close opacity constrain      }// close if  }  //close loop K    // create the node / ellipse    var ell = doc.pathItems.ellipse(n[1] + diam/2,n[0] -diam/2, diam, diam, true,true );    if(f <=0){f=0;}// constrain f (fillcolor)    if(f >=255){f=255;}// constrain f (fillcolor)        fillColor.red = f;    fillColor.green = f;    fillColor.blue = f;    ell.fillColor = fillColor;     ell.strokeColor = strkColor;     ell.strokeWidth = 0.5;     ell.opacity = o;     var ellsTag = ell.tags.add();     ellsTag.name = "ellipse";      } // close loop J        for(var l = 0; l < doc.pathItems.length; l++){    var p = doc.pathItems[l];    if(p.tags[0].name.match("ellipse")){        p.zOrder(ZOrderMethod.BRINGTOFRONT);        }    } // end L loop        }// close main// found on the web// http://www.mathopenref.com/coorddist.htmlfunction calcDistance  ( p, q){   var dx   = p[0] - q[0];         //horizontal difference   var dy   = p[1] - q[1];         //vertical difference   var dist = Math.sqrt( dx*dx + dy*dy ); //distance using Pythagoras theorem  return dist;}