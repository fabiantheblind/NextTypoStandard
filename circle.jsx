// making pretty stuff in InDesign// Copyright (C) 2011 Fabian "fabiantheblind" Morón Zirfas// http://www.the-moron.net// info [at] the - moron . net// This program is free software: you can redistribute it and/or modify// it under the terms of the GNU General Public License as published by// the Free Software Foundation, either version 3 of the License, or// any later version.// This program is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the// GNU General Public License for more details.// You should have received a copy of the GNU General Public License// along with this program.  If not, see <http://www.gnu.org/licenses/.// what is the InDesign targetengine ?// if you want to store something e.g. a value or a string// you can define a targetsession with a specific name of you choice// this session will exist until you close InDesign// use this only if you know for shure what you are doing// for example run thisscript in InDesign:/*    #targetengine "session01"    var myValue = 0;    alert(myValue);    myValue++;*///than this one;/*    #targetengine "session01"    alert(myValue);*/// InDesign will alert 0 at first as declared// the second script will alert 1// because myValue was stored by the targetengine "session1"// and got incremented at the end of script one// with now targetengine declared InDesign will create at launch his own engine// and destroy that after the script execution// this is "garbage collection"// this would be our engine// #targetengine "TypoStandard"var license = new Array();// this is for having some textlicense[0] = "Copyright (C) 2011 Fabian \"fabiantheblind\" Morón Zirfas\n",license[1] = "http://www.the-moron.net\n ";license[2] = "info [at] the - moron . net\n";license[3] = "This program is free software: you can redistribute it and/or modify\n";license[4] = "it under the terms of the GNU General Public License as published by\n";license[5] = "the Free Software Foundation, either version 3 of the License, or\n";license[6] = "any later version.\n";license[7] = "\n";license[8] = "This program is distributed in the hope that it will be useful,\n";license[9] = "but WITHOUT ANY WARRANTY; without even the implied warranty of\n";license[10] = "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n";license[11] = "GNU General Public License for more details.\n";license[12] = "\n";license[13] = "You should have received a copy of the GNU General Public License";license[14] = "along with this program.  If not, see http://www.gnu.org/licenses/";                var ps = 160; // the pagesize// create a new document with a width and a heightvar doc  = app.documents.add()with(doc.documentPreferences){    pageWidth  = ps;    pageHeight = ps;    };var p = doc.pages[0];// get the first page of that documentvar dist = ps/10; // this is the distance from the page sidesvar pw = doc.documentPreferences.pageWidth; // the widthvar ph = doc.documentPreferences.pageHeight; // the heightvar ovs = new Array(); // create a new array for the ovals// lets make 20 circles// or use license.lengthfor(var i = 0; i < license.length ; i++){	    // calculate the ovals geometricBounds    var y1 = dist + (i * 3); // from top the upper left point    var x1 = dist + (i * 3); // from left  the upper left point    var y2 = ph - dist - (i * 3); // from top  the lower right point    var x2 = pw -dist - (i * 3); // from left  the lower right point        //create a circle and put him into the array ovs    ovs.push(p.ovals.add({geometricBounds:[y1,x1,y2,x2]}));        ovs[i].strokeWeight = 0;   // we dont want to see the circles    ovs[i].textPaths.add(); // add a textpath to the circle    // these are some transformation types	var rotTM = app.transformationMatrices.add({counterclockwiseRotationAngle:(i*10)+180 });// rotate (the 180 is for getting the line start upwards)	var hrTM = app.transformationMatrices.add({horizontalTranslation:i*2});// transform horizontal	var vrTM = app.transformationMatrices.add({verticalTranslation:i*-2});// transform vertical    var vrScaleTM = app.transformationMatrices.add({verticalScaleFactor:0.7});// scale vertical with the factor 0.7    var hrScaleTM = app.transformationMatrices.add({horizontalScaleFactor:0.7});// scale horizontal with the factor 0.7//~     var shearTM = app.transformationMatrices.add({clockwiseShearAngle:45}); // shear	    // now connect the path with the previous one    // this works with the second oval not the first    if(i > 0){        ovs[i].textPaths[0].previousTextFrame = ovs[i-1].textPaths[0];        }// close if i > 0                // apply the Transformation Matricies		ovs[i].transform(CoordinateSpaces.pasteboardCoordinates, AnchorPoint.centerAnchor, rotTM);        		ovs[i].transform(CoordinateSpaces.pasteboardCoordinates, AnchorPoint.centerAnchor, vrTM);		ovs[i].transform(CoordinateSpaces.pasteboardCoordinates, AnchorPoint.centerAnchor, hrTM);//~ 		ovs[i].transform(CoordinateSpaces.pasteboardCoordinates, AnchorPoint.centerAnchor, vrScaleTM);//~ 		ovs[i].transform(CoordinateSpaces.pasteboardCoordinates, AnchorPoint.centerAnchor, hrScaleTM);//~         ovs[i].transform(CoordinateSpaces.pasteboardCoordinates, AnchorPoint.centerAnchor, shearTM );            }// close for loop i < 20// now add some  text to the circles// we only have to do this once. each overflow goes into the next Circle Pathovs[0].textPaths[0].contents = TextFrameContents.placeholderText;//license.join("");//TextFrameContents.placeholderText;/** * Now comes the text editing part * we will loop thru all words and change their size *  */// start another loop for all ovalsvar k = 0;while(k < ovs.length){    // start another loop for all textpaths on every oval    var j = 0;    while(j < ovs[k].textPaths.length){                // start another loop for all words on every textpath on every oval        var i = 0;        while(i < ovs[k].textPaths[j].words.length){            ovs[k].textPaths[j].words.item(i).pointSize = 5 + Math.random()*10;            i++;            }// close i loop        j++;        }//close j loop    k++;    }//close k loop// and we are done